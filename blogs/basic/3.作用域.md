# 作用域

## 编译器

1. **分词/词法分析**

   将一连串字符打断成有意义的片段，称为 token（记号）

   ```js
   var a = 2;
   // var，a，=，2，和 ;
   ```

2. **解析**

   将一个 token 的流（数组）转换为一个嵌套元素的树，抽象语法树”（AST ）

3. **代码生成**

   这个处理将抽象语法树转换为可执行的代码

### 概念

1. *引擎*：负责从始至终的编译和执行我们的 JavaScript 程序。
2. *编译器*：处理所有的解析和代码生成。
3. *作用域*：收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量实施一组规则。

### `var a = 2;` 过程：

- **编译器** 声明一个变量（如果先前没有在当前作用域中声明过）
- 当执行时，**引擎** 在 **作用域** 中查询这个变量并给它赋值，如果找到的话

### 编译器术语

#### LHS 和 RHS

“Left-hand Side（左手边）”和“Right-hand Side（右手边）

当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，（找到这个变量）

当一个变量出现在赋值操作的右手边时（或者不是左手边），会进行 RHS 查询， （取变量的值）

```js
 // LHS 查询（有3处！）。
 // RHS 查询（有4处！）。
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

## 嵌套的作用域

#### 遍历嵌套 *作用域* 的简单规则：

- *引擎* 从当前执行的 *作用域* 开始，在那里查找变量，
- 如果没有找到，就向上走一级继续查找，如此类推。
- 如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量。

## 错误

```js
function foo(a) {
	console.log( a + b ); // VM42:2 Uncaught ReferenceError: b is not defined
	b = a;
}

foo( 2 );
```

### RHS（查询某个变量的值，如=号右边）

如果 RHS 查询在嵌套的 *作用域* 的任何地方都找不到一个值，这会导致 *引擎* 抛出一个 `ReferenceError`

如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 `null` 或者 `undefined` 值的属性，那么 *引擎* 就会抛出一个不同种类的错误，称为 `TypeError`。

### LHS（找到变量容器本身，如=号左边）

如果 *引擎* 在进行一个 LHS 查询，但到达了顶层（全局 *作用域*）都没有找到它，

而且如果程序没有运行在“Strict模式”下，（Strict会报ReferenceError）

那么这个全局 *作用域* 将会在 **全局作用域中** 创建一个同名的新变量，并把它交还给 *引擎*

## 欺骗词法作用域

- eval
- with
- new Function 最后一个参数为字符串
- setTimeout setInterval 第一个参数为字符串

如果出现 eval、with *引擎* 在编译阶段期行许多性能优化工作都会失效，也就是会影响性能

## 形成作用域

- function () {}
- catch () {}
- { let a = 123; const b = 123; }

## 声明提升

var 和 function

同时存在，var的提升会被忽略掉

```js
foo(); // 1

var foo;

function foo() {
	console.log( 1 );
}

foo = function() {
	console.log( 2 );
};

foo() // 2
```

## 闭包

闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。

## 动态作用域（js没有）

**词法作用域是编写时的，而动态作用域（和 `this`）是运行时的**。词法作用域关心的是 *函数在何处被声明*，但是动态作用域关心的是函数 *从何处* 被调用。